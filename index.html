<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>PDF編集アプリ</title>
  <style>
    body { font-family: sans-serif; padding: 20px; }
    canvas { border: 1px solid #ccc; margin: 10px 0; display: block; }
    .page-block { margin-bottom: 20px; }
  </style>
</head>
<body>
  <h1>PDF編集アプリ</h1>
  <input type="file" id="fileInput" accept="application/pdf" />
  <div>
    <button id="deletePagesBtn">選択ページを削除</button>
    <button id="downloadBtn">PDFをダウンロード</button>
  </div>
  <div id="pdfContainer"></div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/pdf-lib/dist/pdf-lib.min.js"></script>
  <script>
    const fileInput = document.getElementById('fileInput');
    const container = document.getElementById('pdfContainer');
    const deleteBtn = document.getElementById('deletePagesBtn');
    const downloadBtn = document.getElementById('downloadBtn');

    let loadedPdfBytes = null;
    let currentPdfDoc = null;

    fileInput.addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (!file) return;

      loadedPdfBytes = await file.arrayBuffer();
      currentPdfDoc = await PDFLib.PDFDocument.load(loadedPdfBytes);

      const pdf = await pdfjsLib.getDocument({ data: loadedPdfBytes }).promise;
     // ページ削除処理のあとに再描画
container.innerHTML = ''; // 一度すべて削除

const pdfBytes = await currentPdfDoc.save(); // 最新状態で
const reloadedPdf = await pdfjsLib.getDocument({ data: pdfBytes }).promise;

for (let i = 1; i <= reloadedPdf.numPages; i++) {
  const page = await reloadedPdf.getPage(i);
  const scale = 0.5;
  const viewport = page.getViewport({ scale });

  const canvas = document.createElement('canvas');
  const context = canvas.getContext('2d');
  canvas.width = viewport.width;
  canvas.height = viewport.height;

  await page.render({ canvasContext: context, viewport }).promise;

  const pageBlock = document.createElement('div');
  pageBlock.className = 'page-block';

  const checkbox = document.createElement('input');
  checkbox.type = 'checkbox';
  checkbox.value = i - 1;

  pageBlock.appendChild(canvas);
  pageBlock.appendChild(document.createTextNode(`ページ ${i}`));
  pageBlock.appendChild(checkbox);
  container.appendChild(pageBlock);
}

    });

    deleteBtn.addEventListener('click', async () => {
      if (!currentPdfDoc) return;

      const checkboxes = container.querySelectorAll('input[type="checkbox"]:checked');
      const pagesToDelete = Array.from(checkboxes).map(cb => parseInt(cb.value));
      pagesToDelete.sort((a, b) => b - a); // 後ろから削除

      pagesToDelete.forEach(index => currentPdfDoc.removePage(index));
      alert(`${pagesToDelete.length}ページ削除しました`);
    });

    downloadBtn.addEventListener('click', async () => {
      if (!currentPdfDoc) return;
      const pdfBytes = await currentPdfDoc.save();
      const blob = new Blob([pdfBytes], { type: 'application/pdf' });
      const url = URL.createObjectURL(blob);

      const a = document.createElement('a');
      a.href = url;
      a.download = 'edited.pdf';
      a.click();

      URL.revokeObjectURL(url);
    });
  </script>
</body>
</html>
